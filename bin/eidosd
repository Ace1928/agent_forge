#!/usr/bin/env python3
"""eidosd â€” daemon shim with heartbeat loop."""

from __future__ import annotations
import argparse
import sys
from pathlib import Path as _P
try:
    import yaml
except Exception:
    yaml = None

# add repo root to sys.path for local imports
sys.path.insert(0, str(_P(__file__).resolve().parents[1]))

from core import state as S  # type: ignore
from core import events as E  # type: ignore
from core import db as DB    # type: ignore
from core import os_metrics as OM  # type: ignore
from core import scheduler as SCH  # type: ignore


def run_once(state_dir: str, *, tick_secs: float, cpu: OM.CpuPercent) -> None:
    """Execute one beat: collect metrics, emit event, journal."""
    p = OM.process_stats()
    s = OM.system_stats()
    cpu_pct = cpu.sample()
    metrics = {
        "process.rss_bytes": p.get("rss_bytes"),
        "process.cpu_user_s": p.get("cpu_user_s"),
        "process.cpu_sys_s": p.get("cpu_sys_s"),
        "process.cpu_pct": cpu_pct,
        "system.load1": s.get("load1"),
        "system.load5": s.get("load5"),
        "system.load15": s.get("load15"),
        "system.mem_total_kb": s.get("mem_total_kb"),
        "system.mem_free_kb": s.get("mem_free_kb"),
        "system.mem_available_kb": s.get("mem_available_kb"),
    }
    for name, val in metrics.items():
        if val is not None:
            DB.insert_metric(state_dir, name, float(val))
    payload = {
        "tick_secs": float(tick_secs),
        "rss_bytes": p.get("rss_bytes"),
        "cpu_pct": cpu_pct,
        "load1": s.get("load1"),
        "mem_available_kb": s.get("mem_available_kb"),
    }
    DB.insert_journal(state_dir, "daemon.beat", "beat")
    E.append(state_dir, "daemon.beat", payload, tags=["daemon", "beat"])
    S.append_journal(state_dir, "daemon.beat", etype="daemon.beat")


def _load_cfg() -> dict:
    cfg_path = _P("cfg/self.yaml")
    if yaml is None or not cfg_path.exists():
        return {}
    try:
        with cfg_path.open("r", encoding="utf-8") as f:
            data = yaml.safe_load(f) or {}
        return data.get("daemon", {})
    except Exception:
        return {}


def main(argv: list[str] | None = None) -> int:
    ap = argparse.ArgumentParser(prog="eidosd", description="Minimal Eidos daemon")
    ap.add_argument("--state-dir", default="state", help="state directory")
    ap.add_argument("--once", action="store_true", help="run one cycle then exit")
    ap.add_argument("--loop", action="store_true", help="run scheduler loop")
    ap.add_argument("--tick", type=float, help="seconds between beats")
    ap.add_argument("--max-beats", type=int, default=0, help="stop after N beats (0=inf)")
    ap.add_argument("--jitter-ms", type=int, help="jitter per beat in ms")
    args = ap.parse_args(argv)

    cfg = _load_cfg()
    tick_secs = float(args.tick if args.tick is not None else cfg.get("tick_secs", 5))
    jitter_ms = int(args.jitter_ms if args.jitter_ms is not None else cfg.get("jitter_ms", 0))
    max_backoff = float(cfg.get("max_backoff_secs", 30.0))
    max_beats = int(args.max_beats or cfg.get("max_beats", 0))

    try:
        S.migrate(args.state_dir)
        DB.init_db(args.state_dir)
    except Exception as e:
        print(f"eidosd setup error: {e}", file=sys.stderr)
        return 1

    cpu = OM.CpuPercent()
    if args.once:
        try:
            run_once(args.state_dir, tick_secs=tick_secs, cpu=cpu)
            return 0
        except Exception as e:
            print(f"eidosd run error: {e}", file=sys.stderr)
            return 2
    if args.loop:
        token = SCH.StopToken()
        SCH.install_sigint(token)
        cfg_obj = SCH.BeatCfg(
            tick_secs=tick_secs,
            jitter_ms=jitter_ms,
            max_backoff_secs=max_backoff,
            max_beats=max_beats,
        )
        try:
            SCH.run_loop(cfg_obj, lambda: run_once(args.state_dir, tick_secs=tick_secs, cpu=cpu), stop=token)
            return 0
        except Exception as e:
            print(f"eidosd loop error: {e}", file=sys.stderr)
            return 2
    ap.error("must specify --once or --loop")
    return 2


if __name__ == "__main__":  # pragma: no cover
    sys.exit(main())
